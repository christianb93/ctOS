/*
 * testwait.c
 *
 */

#include <stdio.h>
#include <signal.h>
#include <sys/wait.h>
#include <unistd.h>
#include <errno.h>

/*
 * Macro for assertions in unit test cases
 */
#define ASSERT(x)  do { if (!(x)) { \
        printf("Assertion %s failed at line %d in %s..", #x, __LINE__, __FILE__ ); \
        return 1 ;   \
} \
} while (0)

/*
 * Set up statistics
 */
#define INIT  int __failed=0; int __passed=0; int __rc=0 ; \
        printf("------------------------------------------\n"); \
        printf("Starting unit test %s\n", __FILE__); \
        printf("------------------------------------------\n");

/*
 * Print statistic and return
 */
#define END printf("------------------------------------------\n"); \
        printf("Overall test results (%s):\n", __FILE__); \
        printf("------------------------------------------\n"); \
        printf("Failed: %d  Passed:  %d\n", __failed, __passed); \
        printf("------------------------------------------\n");
/*
 * Execute a test case
 */
#define RUN_CASE(x) do { __rc= do_test_case(x, testcase##x);  \
        if (__rc) __failed++; else __passed++;} while (0)

/*
 * Forward declaration - this is in kunit.o
 */
int do_test_case(int x, int (*testcase)());

/*
 * Signal handler for sigchld
 */
static int volatile sigchld = 0;
void sigchld_handler(int sig_no) {
    if (SIGCHLD==sig_no)
        sigchld = 1;
}

/*
 * Signal handler for sigusr1
 */
static int volatile sigusr1 = 0;
void sigusr1_handler(int sig_no) {
    if (SIGUSR1==sig_no)
        sigusr1 = 1;
}

/*
 * Testcase 1: create a process which exits immediately with status zero and verify that wait returns the correct
 * result
 */
int testcase1() {
    int status;
    int pid;
    pid = fork();
    ASSERT(pid>=0);
    if (0==pid) {
        _exit(0);
    }
    ASSERT(pid==waitpid(pid, &status, 0));
    ASSERT(WIFEXITED(status));
    ASSERT(0==WEXITSTATUS(status));
    return 0;
}

/*
 * Testcase 2: create a process which exits immediately with status one and verify that wait returns the correct
 * result
 */
int testcase2() {
    int pid;
    int status;
    pid = fork();
    if (0==pid) {
        _exit(1);
    }
    ASSERT(pid>=0);
    ASSERT(pid==waitpid(pid, &status, 0));
    ASSERT(WIFEXITED(status));
    ASSERT(WEXITSTATUS(status)==1);
    return 0;
}

/*
 * Testcase 3: create a process which is killed and verify that wait returns the correct status
 */
int testcase3() {
    int pid;
    int status;
    pid = fork();
    if (0==pid) {
        while(1);
    }
    ASSERT(pid>=0);
    ASSERT(0==kill(pid, SIGTERM));
    ASSERT(pid==waitpid(pid, &status, 0));
    ASSERT(WIFEXITED(status)==0);
    ASSERT(WIFSIGNALED(status));
    ASSERT(SIGTERM==WTERMSIG(status));
    return 0;
}

/*
 * Testcase 4: create a process which terminates immediately and catch the SIGCHLD signal generated by it. Then
 * call wait to retrieve the status information
 */
int testcase4() {
    int pid;
    int status;
    struct sigaction sa;
    /*
     * Install handler
     */
    sa.sa_flags = 0;
    sa.sa_handler = sigchld_handler;
    sigemptyset(&sa.sa_mask);
    sigchld = 0;
    ASSERT(0==sigaction(SIGCHLD, &sa, 0));
    /*
     * Create child process which exits
     */
    pid = fork();
    if (0==pid) {
        _exit(5);
    }
    ASSERT(pid>=0);
    /*
     * Wait for sigchld-flag
     */
    while (!sigchld) {
        pause();
    }
    ASSERT(pid==waitpid(pid, &status, 0));
    ASSERT(WIFEXITED(status));
    ASSERT(5==WEXITSTATUS(status));
    /*
     * Remove handler again
     */
    sa.sa_handler = SIG_DFL;
    ASSERT(0==sigaction(SIGCHLD, &sa, 0));
    return 0;
}

/*
 * Testcase 5: create a process which terminates immediately and catch the SIGCHLD signal generated by it. Then
 * call wait with the option WNOHANG to retrieve the status information. This is like testcase 4, with the only
 * difference that it uses WNOHANG
 */
int testcase5() {
    int pid;
    int status;
    struct sigaction sa;
    /*
     * Install handler
     */
    sa.sa_flags = 0;
    sa.sa_handler = sigchld_handler;
    sigemptyset(&sa.sa_mask);
    sigchld = 0;
    ASSERT(0==sigaction(SIGCHLD, &sa, 0));
    /*
     * Create child process which exits
     */
    pid = fork();
    if (0==pid) {
        _exit(5);
    }
    ASSERT(pid>=0);
    /*
     * Wait for sigchld-flag
     */
    while (!sigchld) {
        pause();
    }
    ASSERT(pid==waitpid(pid, &status, WNOHANG));
    ASSERT(WIFEXITED(status));
    ASSERT(5==WEXITSTATUS(status));
    /*
     * Remove handler again
     */
    sa.sa_handler = SIG_DFL;
    ASSERT(0==sigaction(SIGCHLD, &sa, 0));
    return 0;
}

/*
 * Testcase 6: create a process which is then stopped. Then
 * call wait with the option WUNTRACED to retrieve the status information.
 */
int testcase6() {
    int pid;
    int status;
    /*
     * Create child process which loops
     */
    pid = fork();
    if (0==pid) {
        while(1);
    }
    ASSERT(pid>=0);
    /*
     * Suspend it
     */
    ASSERT(0==kill(pid, SIGSTOP));
    status = 0;
    ASSERT(pid==waitpid(pid, &status, WUNTRACED));
    ASSERT(WIFSTOPPED(status));
    ASSERT(SIGSTOP==WSTOPSIG(status));
    /*
     * Then kill process and wait again
     */
    ASSERT(0==kill(pid, SIGKILL));
    status = 0;
    ASSERT(pid==waitpid(pid, &status, 0));
    ASSERT(WIFSIGNALED(status));
    ASSERT(SIGKILL==WTERMSIG(status));
    return 0;
}

/*
 * Testcase 7: create two child processes and wait for them
 */
int testcase7() {
    int rc;
    int i;
    int pid[2];
    int done[2];
    int status;
    done[0]=0;
    done[1]=0;
    /*
     * Create child process which exits
     */
    pid[0] = fork();
    if (0==pid[0]) {
        _exit(1);
    }
    ASSERT(pid[0]>=0);
    /*
     * Fork off second process
     */
    pid[1] = fork();
    if (0==pid[1]) {
        _exit(1);
    }
    ASSERT(pid[1]>=0);
    /*
     * And wait for both processes
     */
    for (i=0;i<2;i++) {
        rc = waitpid(-1, &status, 0);
        ASSERT((rc==pid[0]) || (rc==pid[1]));
        if (rc==pid[0])
            done[0]=1;
        else
            done[1]=1;
    }
    ASSERT(done[0]==1);
    ASSERT(done[1]==1);
    ASSERT(-1==waitpid(-1, &status, WNOHANG));
    return 0;
}

/*
 * Testcase 8: this is like testcase 1, except with a sleep to make sure that the task has really exited before we enter
 * waitpid
 */
int testcase8() {
    int status;
    int pid;
    pid = fork();
    ASSERT(pid>=0);
    if (0==pid) {
        _exit(0);
    }
    sleep(1);
    ASSERT(pid==waitpid(pid, &status, 0));
    ASSERT(WIFEXITED(status));
    ASSERT(0==WEXITSTATUS(status));
    return 0;
}

/*
 * Testcase 9: install a signal handler for SIGUSR1, then fork off a child which sends SIGUSR1 while we are in a waitpid.
 * Verify that waitpid returns -EINTR, but a second call returns the correct result
 */
int testcase9() {
    int status;
    int pid;
    struct sigaction sa;
    int rc;
    /*
     * Install signal handler for SIGUSR1
     */
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sa.sa_handler = sigusr1_handler;
    sigusr1 = 0;
    ASSERT(0==sigaction(SIGUSR1, &sa, 0));
    pid = fork();
    ASSERT(pid>=0);
    if (0==pid) {
        /*
         * sleep to make sure that the mainline had time to
         * enter waitpid, then send SIGUSR1. Wait one more second to make sure
         * that the status is not available
         */
        sleep(1);
        kill(getppid(), SIGUSR1);
        sleep(1);
        _exit(0);
    }
    rc = waitpid(pid, &status, 0);
    ASSERT(-1==rc);
    ASSERT(errno==EINTR);
    ASSERT(1==sigusr1);
    ASSERT(pid==waitpid(pid, &status, 0));
    ASSERT(WIFEXITED(status));
    ASSERT(0==WEXITSTATUS(status));
    /*
     * Remove handler again
     */
    sa.sa_handler = SIG_DFL;
    ASSERT(0==sigaction(SIGUSR1, &sa, 0));
    return 0;
}

/*
 * Testcase 10: install a signal handler for SIGCHLD, then fork and exit a child. Verify that the first waitpid already returns
 * the correct status
 *
 * NOTE: the behavior in this situation is declared as implementation specific - ctOS will return the status code, but will
 * also execute the signal handler. This is similar to the Linux behaviour
 */
int testcase10() {
    int status;
    int pid;
    struct sigaction sa;
    /*
     * Install signal handler for SIGCHLD
     */
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sa.sa_handler = sigchld_handler;
    sigchld = 0;
    ASSERT(0==sigaction(SIGCHLD, &sa, 0));
    pid = fork();
    ASSERT(pid>=0);
    if (0==pid) {
        /*
         * sleep to make sure that the mainline had time to
         * enter waitpid, then exit - this will create SIGCHLD
         */
        sleep(1);
        _exit(0);
    }
    ASSERT(pid==waitpid(pid, &status, 0));
    ASSERT(WIFEXITED(status));
    ASSERT(0==WEXITSTATUS(status));
    ASSERT(sigchld==1);
    /*
     * Remove handler again
     */
    sa.sa_handler = SIG_DFL;
    ASSERT(0==sigaction(SIGCHLD, &sa, 0));
    return 0;
    return 0;
}

/*
 * Testcase 11: install a signal handler for SIGCHLD, but block the signal. Then fork and exit a child. Verify that the first waitpid
 * already returns the correct result and that no SIGCHLD is pending any more
 */
int testcase11() {
    int status;
    int pid;
    struct sigaction sa;
    sigset_t mask;
    /*
     * Install signal handler for SIGCHLD
     */
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sa.sa_handler = sigchld_handler;
    sigchld = 0;
    ASSERT(0==sigaction(SIGCHLD, &sa, 0));
    /*
     * Now block SIGCHLD
     */
    sigemptyset(&mask);
    sigaddset(&mask, SIGCHLD);
    ASSERT(0==sigprocmask(SIG_BLOCK, &mask, 0));
    /*
     * and fork
     */
    pid = fork();
    ASSERT(pid>=0);
    if (0==pid) {
        /*
         * sleep to make sure that the mainline had time to
         * enter waitpid, then exit - this will create SIGCHLD
         */
        sleep(1);
        _exit(0);
    }
    ASSERT(pid==waitpid(pid, &status, 0));
    ASSERT(0==sigchld);
    ASSERT(WIFEXITED(status));
    ASSERT(0==WEXITSTATUS(status));
    /*
     * Remove handler again
     */
    sa.sa_handler = SIG_DFL;
    ASSERT(0==sigaction(SIGCHLD, &sa, 0));
    return 0;
    return 0;
}

/*
 * Testcase 12: install a signal handler for SIGCHLD. Then fork and exit a child and stop it. Verify that a SIGCHLD is raised.
 * Then block SIGCHLD, kill the child process and wait for it
 */
int testcase12() {
    int status;
    int pid;
    struct sigaction sa;
    sigset_t mask;
    /*
     * Install signal handler for SIGCHLD and make
     * sure that the signal is unblocked
     */
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sa.sa_handler = sigchld_handler;
    sigchld = 0;
    ASSERT(0==sigaction(SIGCHLD, &sa, 0));
    sigemptyset(&mask);
    ASSERT(0==sigprocmask(SIG_SETMASK, &mask, 0));
    /*
     * and fork
     */
    pid = fork();
    ASSERT(pid>=0);
    if (0==pid) {
        while(1);
    }
    /*
     * Stop the child
     */
    ASSERT(0==kill(pid, SIGSTOP));
    /*
     * and wait for SIGCHLD
     */
    while (0==sigchld);
    /*
     * Now block SIGCHLD
     */
    sigemptyset(&mask);
    sigaddset(&mask, SIGCHLD);
    ASSERT(0==sigprocmask(SIG_BLOCK, &mask, 0));
    /*
     * Kill stopped task and wait for it
     */
    ASSERT(0==kill(pid, SIGKILL));
    ASSERT(pid==waitpid(pid, &status, 0));
    ASSERT(WIFSIGNALED(status));
    /*
     * Remove handler again
     */
    sa.sa_handler = SIG_DFL;
    ASSERT(0==sigaction(SIGCHLD, &sa, 0));
    return 0;
}

int main() {
    INIT;
    RUN_CASE(1);
    RUN_CASE(2);
    RUN_CASE(3);
    RUN_CASE(4);
    RUN_CASE(5);
    RUN_CASE(6);
    RUN_CASE(7);
    RUN_CASE(8);
    RUN_CASE(9);
    RUN_CASE(10);
    RUN_CASE(11);
    RUN_CASE(12);
    return __failed;
}

